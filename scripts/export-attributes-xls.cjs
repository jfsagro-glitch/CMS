/* eslint-disable no-console */
/**
 * Export unified attributes with hierarchy to XLS (BIFF8) for correct Windows/Excel display.
 * Input: Spravochniki/str/unified-attributes.json (generated by index-spravochniki.cjs)
 * Output: Spravochniki/str/unified-attributes.xls
 */

const fs = require('fs');
const path = require('path');
const xlsx = require('xlsx');

function normalizeBaseKey(key) {
  // remove trailing _YYYYMMDDHHMM or numeric suffixes
  const removedTimestamp = key.replace(/_\d{12}$/, '');
  return removedTimestamp;
}

function buildHierarchy(unified) {
  // Merge dictionaries with the same normalized baseKey
  const dictByBaseKey = new Map();
  for (const d of unified.dictionaries || []) {
    const baseKey = normalizeBaseKey(d.key);
    if (!dictByBaseKey.has(baseKey)) {
      dictByBaseKey.set(baseKey, {
        ...d,
        key: baseKey,
        sourceFiles: [d.sourceFile],
      });
    } else {
      const existing = dictByBaseKey.get(baseKey);
      existing.items = existing.items || [];
      existing.items.push(...(d.items || []));
      existing.sourceFiles.push(d.sourceFile);
      // Prefer first meta/labelKey
    }
  }

  // Prepare attribute entries
  const attrByCode = new Map();
  const entries = [];
  for (const [baseKey, d] of dictByBaseKey.entries()) {
    const entry = {
      id: `attr-${baseKey}`,
      code: baseKey,
      name: baseKey.replace(/_/g, ' '),
      type: 'enum',
      level: 2,
      parentCode: null,
      valuesCount: d.items?.length || 0,
      sourceFiles: (d.sourceFiles || []).join(', '),
    };
    entries.push(entry);
    attrByCode.set(baseKey, entry);
  }

  // Heuristic parent mapping from generic to specific
  const parentMap = {
    collateral_status: 'collateral_type',
    monitoring_period: 'collateral_type',
    house_type: 'real_estate_type',
    apartment_condition: 'real_estate_type',
    veksel_location: 'issue_security_type',
  };

  // Assign default levels by keyword
  for (const e of entries) {
    const code = e.code;
    const isLevel1Keyword =
      /(^|_)type($|_)|(^|_)category($|_)|(^|_)status($|_)|^real_estate_type$|^ownership_type$|^collateral_type$|^liquidity_levels$|^issue_security_type$|^pledge_agreement_type$|^property_document_type$/.test(
        code
      );
    e.level = isLevel1Keyword ? 1 : 2;
    // Apply explicit parent mapping if exists
    const base = normalizeBaseKey(code);
    if (parentMap[base]) {
      e.parentCode = parentMap[base];
      if (e.level <= 1) e.level = 2; // child cannot be level 1 if it has a parent
    }
  }

  // Link parentId by code
  for (const e of entries) {
    if (e.parentCode && attrByCode.has(e.parentCode)) {
      e.parentId = attrByCode.get(e.parentCode).id;
    } else {
      e.parentId = '';
    }
  }

  // Build hierarchy rows
  const hierarchy = entries
    .filter(e => e.parentId)
    .map(e => ({
      parentId: e.parentId,
      parentCode: e.parentCode,
      childId: e.id,
      childCode: e.code,
    }));

  return { entries, hierarchy };
}

function toSheet(json) {
  const ws = xlsx.utils.json_to_sheet(json, { skipHeader: false });
  return ws;
}

function main() {
  const root = process.cwd();
  const input = path.join(root, 'Spravochniki', 'str', 'unified-attributes.json');
  const output = path.join(root, 'Spravochniki', 'str', 'unified-attributes.xls');

  if (!fs.existsSync(input)) {
    console.error('Input not found:', input);
    process.exit(1);
  }

  const unified = JSON.parse(fs.readFileSync(input, 'utf8'));
  const { entries, hierarchy } = buildHierarchy(unified);

  // Prepare additional sheets: Dictionaries meta
  const dictMeta =
    (unified.dictionaries || []).map(d => ({
      key: normalizeBaseKey(d.key),
      sheet: d.sheet,
      rows: d.meta?.rows || d.items?.length || 0,
      labelKey: d.meta?.labelKey || '',
      columns: (d.meta?.columns || []).join(', '),
      sourceFile: d.sourceFile,
    })) || [];

  const wb = xlsx.utils.book_new();
  xlsx.utils.book_append_sheet(
    wb,
    toSheet(
      entries.map(e => ({
        id: e.id,
        code: e.code,
        name: e.name,
        type: e.type,
        level: e.level,
        parentId: e.parentId,
        parentCode: e.parentCode || '',
        valuesCount: e.valuesCount,
        sourceFiles: e.sourceFiles,
      }))
    ),
    'Attributes'
  );
  xlsx.utils.book_append_sheet(wb, toSheet(hierarchy), 'Hierarchy');
  xlsx.utils.book_append_sheet(wb, toSheet(dictMeta), 'Dictionaries');

  // Write as BIFF8 .xls to ensure compatibility
  xlsx.writeFile(wb, output, { bookType: 'biff8' });
  console.log('âœ… XLS written:', output);
  console.log(`ðŸ“„ Sheets: Attributes(${entries.length}), Hierarchy(${hierarchy.length}), Dictionaries(${dictMeta.length})`);
}

if (require.main === module) {
  main();
}

module.exports = { main };

